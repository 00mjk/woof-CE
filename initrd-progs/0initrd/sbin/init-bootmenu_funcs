#!/bin/sh

TOP_LEFT_CORNER='╔'
TOP_RIGHT_CORNER='╗'
BOTTOM_LEFT_CORNER='╚'
BOTTOM_RIGHT_CORNER='╝'
HORIZONTAL_LINE='═'
VERTICAL_LINE='║'

MENU_COLOR=`echo -en '\033[97;44m'` # blue bg color bright white fg

KEY_UP=`echo -en '\033[A'`
KEY_DOWN=`echo -en '\033[B'`
KEY_ESC=`echo -en '\033\033'`

decode_entry() {
 PDEV1=""
 PDRV=""
 PFIX=""
 PIMOD=""
 PMEDIA=""
 PSAVE=""
 PSAVEMARK=""
 PSUBDIR=""
 PUPSFS=""
 UNDERDOG=""
 ZDRV=""
 FDRV=""
 ADRV=""
 YDRV=""
 SEARCH_DIR=""
 SEARCH_DRIVE=""
 DISTRO_SPECS=""

 #CHOSEN_ENTRY="LABEL raspup|PMEDIA usbflash|"
 while read FIELD VALUE
 do
  [ -z "$FIELD" ] && continue #empty line
  #echo "'$FIELD' = '$VALUE'"
  case "$FIELD" in
   LABEL)  continue ;; #ignore LABEL
   PDEV1)  PDEV1=${VALUE}  ;;
   PDRV)   PDRV=${VALUE}   ;;
   PFIX)   PFIX=${VALUE}   ;;
   PIMOD)  PIMOD=${VALUE}  ;;
   PMEDIA) PMEDIA=${VALUE} ;;
   PSAVE)  PSAVE=${VALUE}  ;;
   PSAVEMARK) PSAVEMARK=${VALUE} ;;
   PSUBDIR)   PSUBDIR=${VALUE}   ;;
   PUPSFS)    PUPSFS=${VALUE}    ;;
   UNDERDOG)  UNDERDOG=${VALUE}  ;;
   ZDRV) ZDRV=${VALUE} ;;
   FDRV) FDRV=${VALUE} ;;
   ADRV) ADRV=${VALUE} ;;
   YDRV) YDRV=${VALUE} ;;
   SEARCH_DIR)   SEARCH_DIR=${VALUE}   ;;
   SEARCH_DRIVE) SEARCH_DRIVE=${VALUE} ;;
   DISTRO_SPECS) DISTRO_SPECS=${VALUE} ;;
   *) echo "Ignoring unknown keyword: $ENTRY_PART" ;;
  esac
 done <<EOF
$(echo "$CHOSEN_ENTRY" | tr '|' '\n')
EOF
}

draw_screen() {
 echo -en '\033[s' # save cursor position

 echo -en '\033[2J' # clear screen
 echo -en "\033[${MENU_ROW_START};${MENU_COLUMN_START}H" # goto menu start
 CURRENT_ROW=${MENU_ROW_START}
 CURRENT_COLUMN=${MENU_COLUMN_START}

 echo -n "$MENU_COLOR"
 echo -n "$TOP_LEFT_CORNER"
 let MENU_COLUMN_END=MENU_COLUMN_START+MAX_LABEL_WIDTH+2
 while [ "$CURRENT_COLUMN" -lt "$MENU_COLUMN_END" ]
 do
  echo -n "$HORIZONTAL_LINE"
  let CURRENT_COLUMN++
 done
 echo "$TOP_RIGHT_CORNER"

 echo -en "\033[${MENU_COLUMN_START}G" # move to MENU_COLUMN_START
 CURRENT_COLUMN=${MENU_COLUMN_START}

 CURRENT_ENTRY_NR=0
 TEMP_ALL_ENTRIES=${ALL_ENTRIES}
 while true
 do
  ONE_ENTRY=${TEMP_ALL_ENTRIES%%'
'*}
  TEMP_ALL_ENTRIES=${TEMP_ALL_ENTRIES#*'
'}
  [ "$TEMP_ALL_ENTRIES" = "$ONE_ENTRY" ] && TEMP_ALL_ENTRIES='' # EOF
  [ -z "$ONE_ENTRY" -a -n "$TEMP_ALL_ENTRIES" ] && continue

  let CURRENT_ENTRY_NR++

  if [ "${ONE_ENTRY#LABEL}" != "$ONE_ENTRY" ]; then
   ECHO_STRING=${ONE_ENTRY%%|*}
   ECHO_STRING=${ECHO_STRING:6}
  else
   ECHO_STRING=${ONE_ENTRY%%|*}
  fi

  echo -n "$VERTICAL_LINE"
  if [ "$CURRENT_ENTRY_NR" = "$CHOSEN_ENTRY_NR" ]; then
   CHOSEN_ENTRY=${ONE_ENTRY}
   echo -ne '\033[7m' # reverse video
  fi
  echo -n " $ECHO_STRING"
  let CURRENT_COLUMN=CURRENT_COLUMN+${#ECHO_STRING}+1
  while [ "$CURRENT_COLUMN" -lt "$MENU_COLUMN_END" ]
  do
   echo -n " "
   let CURRENT_COLUMN++
  done
  [ "$CURRENT_ENTRY_NR" = "$CHOSEN_ENTRY_NR" ] && echo -ne '\033[27m' # reset reverse video
  echo "$VERTICAL_LINE"

  echo -en "\033[${MENU_COLUMN_START}G" # move to MENU_COLUMN_START
  CURRENT_COLUMN=${MENU_COLUMN_START}

  [ -z "$TEMP_ALL_ENTRIES" ] && break
 done

 echo -n "$BOTTOM_LEFT_CORNER"
 let MENU_COLUMN_END=MENU_COLUMN_START+MAX_LABEL_WIDTH+2
 while [ "$CURRENT_COLUMN" -lt "$MENU_COLUMN_END" ]
 do
  echo -n "$HORIZONTAL_LINE"
  let CURRENT_COLUMN++
 done
 echo "$BOTTOM_RIGHT_CORNER"
 echo -en '\033[0m' # reset color

 if [ "$TIMEOUT" -ge 10 ]; then
  echo -en "\033[${MENU_COLUMN_START}G" # move to MENU_COLUMN_START
  echo -n "Booting in ${TIMEOUT%[[:digit:]]} seconds..."
 fi

 echo -en '\033[u' # restore cursor position
 echo -en '\033[10D' # backup cursor position
}

exec_init() {

 [ "$PDEV1" ]     && export pdev1=$PDEV1
 [ "$PDRV" ]      && export pdrv=$PDRV
 [ "$PFIX" ]      && export pfix=$PFIX
 [ "$PIMOD" ]     && export pimod=$PIMOD
 [ "$PMEDIA" ]    && export pmedia=$PMEDIA
 [ "$PSAVE" ]     && export psave=$PSAVE
 [ "$PSAVEMARK" ] && export psavemark=$PSAVEMARK
 [ "$PSUBDIR" ]   && export psubdir=$PSUBDIR
 [ "$PUPSFS" ]    && export pupsfs=$PUPSFS
 [ "$UNDERDOG" ]  && export underdog=$UNDERDOG
 [ "$ZDRV" ]      && export zdrv=$ZDRV
 [ "$FDRV" ]      && export fdrv=$FDRV
 [ "$ADRV" ]      && export adrv=$ADRV
 [ "$YDRV" ]      && export ydrv=$YDRV

 export BOOTMENU_DONE=true
 sync
 [ -d "/proc/bus/usb" ] && umount /proc/bus/usb
 umount /sys
 umount /dev
 umount /proc
 # I don't want to exec the system init while testing...
 exec ./init
}

show_menu() {
 let MENU_ROW_START=ROWS-ENTRY_COUNT
 let MENU_ROW_START=MENU_ROW_START/2
 #echo "MENU_ROW_START = $MENU_ROW_START"

 let MENU_COLUMN_START=COLUMNS-MAX_LABEL_WIDTH
 let MENU_COLUMN_START=MENU_COLUMN_START/2
 #echo "MENU_COLUMN_START = $MENU_COLUMN_START"

 [ -z "$CHOSEN_ENTRY_NR" ] && CHOSEN_ENTRY_NR=1
 [ -z "$TIMEOUT" ] && TIMEOUT=0

 while true
 do
  draw_screen

  local TEMP_INPUT=""
  local INPUT=""
  while true
  do
   if [ "$TIMEOUT" -eq 0 ]; then
    read -n1 INPUT
   else
    while true
    do
     read -n1 -t 1 INPUT
     [ "$?" -eq 0 ] && TIMEOUT=0 && break
     if [ "$TIMEOUT" -gt 10 ]; then
      let TIMEOUT=TIMEOUT-10
      draw_screen
     else
      TIMEOUT=0
      break
     fi
    done
   fi
   [ "$INPUT" = "" ] && break

   TEMP_INPUT=${TEMP_INPUT}${INPUT}
   [ "${#TEMP_INPUT}" -gt 3 ] && TEMP_INPUT=${TEMP_INPUT:1}

   # Because arrow key codes start with the ESC charactor, ESC must be pressed
   # twice to exit menu.  KEY_ESC = '\033\033', two ESC chars in a row.
   [ "${TEMP_INPUT}" = "$KEY_ESC" ] && INPUT="" && CHOSEN_ENTRY="" && break
   [ "${TEMP_INPUT:1}" = "$KEY_ESC" ] && INPUT="" && CHOSEN_ENTRY="" && break

   [ "$TEMP_INPUT" = "$KEY_UP"  -a "$CHOSEN_ENTRY_NR" -gt 1 ] && let CHOSEN_ENTRY_NR-- && draw_screen
   [ "$TEMP_INPUT" = "$KEY_DOWN"  -a "$CHOSEN_ENTRY_NR" -lt "$ENTRY_COUNT" ] && let CHOSEN_ENTRY_NR++ && draw_screen

  done
  [ "$INPUT" = "" ] && break
 done
}
