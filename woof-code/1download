#!/bin/sh
#(c) Copyright 2009 Barry Kauler.
#110819 support/findpkgs is new script to find all pkgs to be used in Puppy build.
#120501 support arm build.
#120515 build from "gentoo" binary tarballs (refer support/gentoo).
#120719 support raspbian.

export LANG=C #faster.
[ $1 ] && XPKG=$1 #download specific pkg

. ./_00build.conf
. ./_00func
. ./DISTRO_SPECS
[ ! "$DISTRO_DB_SUBNAME" ] && DISTRO_DB_SUBNAME="$DISTRO_COMPAT_VERSION" #121102 fallback if DISTRO_DB_SUBNAME not defined in file DISTRO_SPECS.
source_compat_repos  # ./DISTRO_COMPAT_REPOS-
source_pkgs_specs    # ./DISTRO_PKGS_SPECS-
. ./DISTRO_PET_REPOS #has PACKAGELISTS_PET_ORDER
create_local_repos_dirs

set_binaries_var #ex: BINARIES=tgz_txz-14.2 BINARIES=deb-xenial

mkdir -p packages-${BINARIES}
mkdir -p packages-pet

function do_exit() { #$1: msg
	kill `cat /tmp/1download_controlpanel_pid` &>/dev/null
	rm -f /tmp/1download_controlpanel_pid &>/dev/null
	echo -e "\n${1}"
	echo -n "Press ENTER key to quit script: "
	read yesgetout
	exit
}

function check_remote_pkg_repos() {
  REPOTYPES="PET COMPAT"
  [ $1 ] && REPOTYPES=$@
  for REPOTYPE in $REPOTYPES ; do
	RMSG=$BINARIES REPOS=$REPOS_DISTRO_COMPAT
	[ "$REPOTYPE" = "PET" ] && RMSG=PET REPOS=$PET_REPOS
	echo -e "\nFinding what $RMSG repos are working..."
	X_URLS=""
	for ONE_X_REPO in $REPOS ; do
		ONE_X_URL="`echo -n "$ONE_X_REPO" | cut -f 2 -d '|'`"
		ONE_X_SITE="`echo -n "$ONE_X_URL" | cut -f 3 -d '/'`"
		if [ "`wget -t 2 -T 30 --waitretry=20 --spider -S $ONE_X_SITE -o /dev/stdout 2>/dev/null | grep '200 OK'`" != "" ];then
			echo "Okay: $ONE_X_URL"
			X_URLS="${X_URLS}${ONE_X_URL} " #success.
		fi
	done
	[ "$X_URLS" = "" ] && do_exit "Failure. Is Internet working?"
	[ "$REPOTYPE" = "PET" ] && PET_URLS=$X_URLS
	[ "$REPOTYPE" = "COMPAT" ] && BIN_URLS=$X_URLS
  done
}

rm -f DOWNLOAD-FAILS-PET 2>/dev/null
rm -f DOWNLOAD-FAILS-${BINARIES} 2>/dev/null
rm -f DOWNLOAD-ERRORS

[ $XPKG ] && CHECK_REMOTE_PKG_REPOS=no
if [ "$CHECK_REMOTE_PKG_REPOS" != "yes" ] ; then
	PET_URLS=$(echo "$PET_REPOS" | tr ' ' '\n' | cut -f 2 -d "|")
	BIN_URLS=$(echo "$REPOS_DISTRO_COMPAT" | tr ' ' '\n' | cut -f 2 -d "|")
else
	check_remote_pkg_repos
fi

##################################
#120501 support arm build, download sd images...
if [ "$DISTRO_TARGETARCH" = "arm" ];then
 mkdir -p sd-skeleton-images
 echo
 echo 'Please wait, probing for online SD skeleton image files...'
 wget -4 -t 2 -T 20 --waitretry=20 --spider --recursive --level=1 --accept '*.xz' -S http://distro.ibiblio.org/quirky/arm/sd-skeleton-images/ 2>&1 | grep '\.xz$' | rev | cut -f 1 -d '/' | rev > /tmp/1download-sd-images-probe
 sync
 if [ ! -s /tmp/1download-sd-images-probe ];then
  echo 'Sorry, could not access any SD images at http://distro.ibiblio.org/quirky/arm/sd-skeleton-images/'
  echo 'Press ENTER to continue script regardless: '
  read keepgoing
  [ "$keepgoing" != "" ] && exit
 else
 
  #ask which sd-image to download...
  ALREADYDOWN="`ls -1 sd-skeleton-images | grep 'xz$'`"
  [ "$ALREADYDOWN" = "" ] && ALREADYDOWN='none'
  SDIMAGEBUTTONS=''
  for ONESDIMAGE in `cat /tmp/1download-sd-images-probe | sort -u | tr '\n' ' '`
  do
   #SDIMAGENAME="`basename $ONESDIMAGE .xz`"
   [ -f sd-skeleton-images/$ONESDIMAGE ] && continue #already downloaded.
   SDIMAGEBUTTONS="${SDIMAGEBUTTONS}<radiobutton><label>${ONESDIMAGE}</label><variable>RADIO_URL_${ONESDIMAGE}</variable></radiobutton>"
  done
  if [ "$SDIMAGEBUTTONS" != "" ];then
   export SDIMAGE_DIALOG="<window title=\"SD Image Downloader: choose file\" icon-name=\"gtk-about\" window_position=\"1\">
   <vbox>
    <text><label>These are already downloaded:</label></text>
    <text><label>\"${ALREADYDOWN}\"</label></text>
    <text><label>Please choose an SD-image file that you would like to download (Click Cancel button to not download any):</label></text>
    <frame>
     ${SDIMAGEBUTTONS}
    </frame>
    <hbox>
     <button ok></button>
     <button cancel></button>
    </hbox>
   </vbox>
   </window>"
   while [ 1 ];do
    RETPARAMS="`gtkdialog3 --program=SDIMAGE_DIALOG`"
    SDIMAGE_FILE=''
    [ "`echo "$RETPARAMS" | grep '^EXIT' | grep 'OK'`" != "" ] && SDIMAGE_FILE="`echo "$RETPARAMS" | grep 'RADIO_URL_' | grep '"true"' | cut -f 1 -d '=' | cut -f 3-9 -d '_'`"
    if [ "$SDIMAGE_FILE" ];then
     cd sd-skeleton-images
     wget -4 http://distro.ibiblio.org/quirky/arm/sd-skeleton-images/$SDIMAGE_FILE
     sync
     wget -4 http://distro.ibiblio.org/quirky/arm/sd-skeleton-images/${SDIMAGE_FILE}.md5.txt
     sync
     cd ..
     echo "...${SDIMAGE_FILE} downloaded to folder sd-skeleton-images"
     if [ -s ${SDIMAGE_FILE}.md5.txt ];then
      CORRECTMD5="`cat ${SDIMAGE_FILE}.md5.txt | cut -f 1 -d ' '`"
      DLMD5="`md5sum ${SDIMAGE_FILE} | cut -f 1 -d ' '`"
      if [ "$CORRECTMD5" != "$DLMD5" ];then
       echo "...however, the md5sum is incorrect. Deleting downloaded file..."
       rm -f $SDIMAGE_FILE
       echo -n "Press ENTER only to continue script, any other key to try download again..."
       read tryagain
       [ "$tryagain" != "" ] && continue    
      fi
     fi
    fi
    break
   done
  fi
  
 fi
fi

run_findpkgs #find all packages that will be used in the Puppy build...

#==============================================================================

function download_controlpanel() {
	export DOWNLOAD_CONTROLPANEL='
<window title="1download control panel" icon-name="gtk-dialog-warning">
 <vbox>
  <hbox>
   <text><label>Pause after current package has downloaded:</label></text>
   <button>
      <label>Pause</label>
      <action>echo 'Pause' > /tmp/1download-status-request</action>
   </button>
  </hbox>
  <hbox>
   <text><label>Resume downloading if currently paused:</label></text>
   <button>
      <label>Resume</label>
      <action>echo 'Resume' > /tmp/1download-status-request</action>
   </button>
  </hbox>
  <hbox>
   <text><label>Quit 1download script after current pkg has download:</label></text>
   <button>
      <label>Quit</label>
      <action>echo 'Quit' > /tmp/1download-status-request</action>
      <action type="exit">Exit</action>
   </button>
  </hbox>
  <text><label>Note: If you Quit, 1download can be run again and will continue from where it left off. That is, previously downloaded packages will not be re-downloaded.</label></text>
 </vbox>
</window>
'
	gtkdialog --program=DOWNLOAD_CONTROLPANEL &
	echo -n $! > /tmp/1download_controlpanel_pid
}

#==============================================================================

echo
echo "Downloading packages..."
LINECNT=1

if [ $XPKG ] ; then
	XFILE=/tmp/zz_downloadpkg
	grep ":${XPKG}:" status/findpkgs_FINAL_PKGS-${DISTRO_BINARY_COMPAT}-${DISTRO_COMPAT_VERSION} | sort > /tmp/zz_downloadpkg
else
	#start the gui controlpanel...
	echo 'Run' > /tmp/1download-status-request
	download_controlpanel
	XFILE=status/findpkgs_FINAL_PKGS-${DISTRO_BINARY_COMPAT}-${DISTRO_COMPAT_VERSION}
fi

#--- called within the loop...
do_echo_file() { #$1: file
  if [ -f "$1" ] ; then
     echo -n " ${DB_fullfilename}" ; continue #already downloaded
  else
     echo -e "\n* Downloading ${DB_fullfilename}"
  fi
}
do_download() { #$1: url
  echo "  - from ${1%/*}"
  #wget -S --spider $1  2>&1 | grep -q '200 OK' || { echo "  not found" ; continue ; }
  wget -c -q --show-progress --timeout=15 $1
  #check file downloaded correctly...
  if [ -f $DB_fullfilename ];then
    case $DB_fullfilename in
     *.deb) # ubuntu|trisquel|debian|devuan|raspbian
      dpkg-deb --extract $DB_fullfilename tempdironly && SUCCESS='yes'
     ;;
     *.txz) # slackware xz
      xz --test $DB_fullfilename &>/dev/null && SUCCESS='yes'
      ;;
     *.tgz) # slackware gzip
       gzip --test $DB_fullfilename &>/dev/null && SUCCESS='yes'
     ;;
     *.pet) # puppy
      cp -f $DB_fullfilename tempfileonly.pet
      pet2tgz tempfileonly.pet && SUCCESS='yes'
      rm -f tempfileonly.pet tempfileonly.tar.* 2>/dev/null
     ;;
     *.tar.bz2) # gentoo
      bzip2 --test $DB_fullfilename &>/dev/null && SUCCESS='yes'
     ;;
    esac
  fi
  rm -rf tempdironly 2>/dev/null
  [ "$SUCCESS" = "no" ] && rm -f ${DB_fullfilename} 2>/dev/null
}
#---

cat $XFILE |
while read ONEDBENTRY
do
 #120812 optional subcategory...
 #ONEDBENTRY=:GENERICNAME:|PETorCOMPAT|DBFILE|pkgname|nameonly|version|pkgrelease|category[;subcategory]|size|path|fullfilename|dependencies|description|compileddistro|compiledrelease|repo|
 #...pkgname onwards is the full db entry for a package.
 IFS="|" read -r F1 F2 F3 F4 F5 F6 F7 F8 F9 F10 F11 F12 F13 <<< "$ONEDBENTRY"
 LINECNT=$(($LINECNT + 1))
 PETorCOMPAT="$F2" #ex: compat
 if [ "$PETorCOMPAT" != "pet" -a "$PETorCOMPAT" != "compat" ];then
  echo -e "\nSyntax ERROR in status/findpkgs_FINAL_PKGS-${DISTRO_BINARY_COMPAT}-${DISTRO_COMPAT_VERSION},"
  echo "line number ${LINECNT}:"
  echo "$ONEDBENTRY"
  echo -n "Ignoring this line, press ENTER to continue (CTRL-C to abort): "
  read KEEPITGOING
  continue
 fi
 DBFILE="$F3"           #ex: Packages-puppy-5-official
 DB_pkgname="$F4"       #ex: abiword-2.3.4-w5
 DB_fullfilename="$F11" #ex: abiword-2.3.4-w5.pet
 DB_path="$F10"         #ex: pet_packages-5
 if [ ! "$DB_path" ];then
  ONLINESUBDIR="`echo -n "$DBFILE" | cut -f 3 -d '-'`"   #ex: 5
  if [ "$PETorCOMPAT" = "pet" ];then #120515
   DB_path="pet_packages-${ONLINESUBDIR}"
  else #compat binary tarballs
   DB_path="compat_packages-${ONLINESUBDIR}"
  fi
 fi
 
 SUCCESS='no'

 if [ "$PETorCOMPAT" = "pet" ];then
  LFILE=DOWNLOAD-FAILS-PET
  do_echo_file packages-pet/${DB_fullfilename}
  for ONE_PET_URL in $PET_URLS ; do
    cd packages-pet
    do_download ${ONE_PET_URL}/${DB_path}/${DB_fullfilename}
    cd ..
    [ "$SUCCESS" = "yes" ] && break
  done 
 else #-- compat
  LFILE=DOWNLOAD-FAILS-${BINARIES}
  do_echo_file packages-${BINARIES}/${DB_fullfilename}
  for ONE_BIN_URL in $BIN_URLS ; do
    cd packages-${BINARIES}
    do_download ${ONE_BIN_URL}/${DB_path}/${DB_fullfilename}
    cd ..
    [ "$SUCCESS" = "yes" ] && { echo "  success" ; break ; }
    echo "  failed (not found or corrupted file)"
  done
 fi #end if PETorCOMPAT

 [ "$SUCCESS" = "no" ] && echo "DOWNLOAD FAIL: ${$DB_fullfilename}"
 [ "$SUCCESS" = "no" ] && echo "$DB_fullfilename" >> ${LFILE}

 #check controlpanel, whether need to pause, resume or quit...
 [ -f /tmp/1download-status-request ] || continue
 CP_STATUS_REQ="`cat /tmp/1download-status-request`" #Run, Pause, Resume, Quit
 pausecnt=0; PIDCP=0
 while [ "$CP_STATUS_REQ" = "Pause" ];do
  #echo "Status: paused ${pausecnt}seconds"
  if [ $PIDCP -eq 0 ];then
   yaf-splash -close never -placement top -bg orange -text "1download script is currently in paused state" &
   PIDCP=$!
  fi
  sleep 5
  pausecnt=`expr $pausecnt + 5`
  CP_STATUS_REQ="`cat /tmp/1download-status-request`"
 done
 [ $PIDCP -ne 0 ] && kill $PIDCP
 [ "$CP_STATUS_REQ" = "Quit" ] && break 2 #pipe into while above is a separate process, need '2' to break out.

done

[ $XPKG ] && echo && exit

[ "$CP_STATUS_REQ" = "Quit" ] && do_exit "1download aborted."
do_exit "\nFinished."

###END###
